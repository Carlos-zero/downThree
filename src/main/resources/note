1, @component   注入bean
2,工具类一般用静态方法？？？
3,静态方法直接通过类访问
4,IOC自动注入的been只会实例化一次    所以   每层都需由IOC要自动注入    @Autowired注解的信息解析成元数据之后，缓存起来，以备复用，每一个类只解析一次。
5,synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），
    运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，
    有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,
    锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。
    Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，
    同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，
    一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
    然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。

6,循环往list中add对象却总是add的是一个对象的原因
 在new 一个对象的时候，对象的ID是唯一确定的；将对象add入list中时，放入list中的其实是对象的引用 ；而每次循环只是简单  的set 对象的属性，set新的属性值，而add进list中的对象还是同一个对象id，也就是同一个对象；
    所以每次add之后，list发现对象引用和之前元素一样，就覆盖掉了之前add的对象。所以循环之后list中的对象是重复的对象。
        想要避免这个问题只要每次add时保证对象引用都是不同的即可，即每循环一次重新new一个对象。
            new的对象应该放在for循环内，每循环一次重新new一个新对象

7,alter table tableName AUTO_INCREMENT beginNum;    自增从0开始

